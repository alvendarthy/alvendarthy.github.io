[{"title":"The general architecture of postgreSQL(2)","url":"/2021/04/06/The-general-architecture-of-postgreSQL-2/","content":"The nature of Database SystemAs PostgreSQL is a DBMS, let’s take a glance on the nature of DB. A text file with some lines of records comes to be a simple database file. Combined with an application manage that file it turns to be a database system. So simple, isn’t it ?\n\nBut the disk IO is very slow you must have notice that, we need some technology to speed it up, so we introduce caches. The cache layer works between the manage application and magnetic disk, any file blocks that hit the cache will just read from the cache rather than from disk, in other words read from memory directly.\n\nSo the nature of DMS is an application which manages some database files, always works with cache to speed up IO. \n","categories":["PostgreSQL"],"tags":["DB"]},{"title":"The general architecture of postgreSQL(1)","url":"/2021/04/04/The-general-architecture-of-postgreSQL-1/","content":"A general viewPostgreSQL is the most advanced Relation Database Management System around the world. It’s a huge system with many complex features. To understand the internal mechanism of PostgreSQL must be a chalange. Let’s start from something much easy to get a whole picture of the system.\nIn this post, I will explain:\n\nhow PostgreSQL works;\nthe process architecture;\nthe system layers;\n\nPostgrepSQL works as multi-processes: 1 master process, several helper processes and worker processes respective to every client.\n\nAll processes are single thread. If you know some services use async io such as nginx and redis, which are epoll driven on Linux implementation, that PostgreSQL use multi-process architecture must beyond your expectation. Actially, this makes sence, for PostgreSQL is heavy on both disk IO and computing, it might take a long time to finish just one query, async io do not allow one job takes such long time or other users be affected.\nWhen a client comes, the master process (named as “postgres”) just accept the connection and produce a new socket corresponding. Then the master process call Linux fork() to create a new worker process, which takes care on the new socket and serves this client ever since. And the worker process quits whenever some error occurs or the client close the connection.\nAll worker processes, helper processes like BGWriter, Vacuum, Logger, access to the Database files concurrently. In this context of PostgreSQL we call the databases as DB cluster, and we call the tables as relations.\n","categories":["PostgreSQL"],"tags":["DB"]},{"title":"Another introduce to sed","url":"/2021/04/08/another-introduce-to-sed/","content":"Why you should learn sedSed is a convenience text edit tool. It’s a free open source software, that means you can use it without paying a cent. If you\n\ndo text edit usually,\nwant to make changes to numerous files in minutes automatically rather than do it manually for hours,\nbe way from dull editing jobs.\n\nYou should learn sed. Unfortunately, sed is a “non-interactive” stream-orinted editor, which means:\n\nit does not work like notepad or vi, you will not see the text proccess.\nit’s stream orinted, sed always works on every single lines, not the whole file, that’s an limitation.\n\n"},{"title":"The memory context of PostgreSQL","url":"/2021/04/15/The-memory-context-of-PostgreSQL/","content":"How to prevent memory leak is such an important topic for every C-language developer. After a long term run, the application eats every bit of RAM and runs so slowly that the OS needs a rebooting. Even worse sometime, the OS just throws a segment fault and shuts down the process immediately. Memory pool is a good fix for this, PostgreSQL has invited this feature after version 9 more or less. This reduced the raisk of memory leak.\nPostgreSQL implements memory infrastructure as The Momory Context. Here are some api you may familiar with:\n\n\n\nAPI\nFor What\n\n\n\nAllocSetContextCreateInternal/AllocSetContextCreate\ncreate  context\n\n\nMemoryContextDelete\nDestroy context\n\n\npalloc\nalloc memory from context\n\n\npfree\nfree memory back to context\n\n\nprealloc\nrealloc memory\n\n\nObviously, they would replace  libc alloc/free functions. I will explain how Memory Context works in this post.\nA tree like relationshipA memory context can specify:\n\na parent context\na child contexts list\n\nIf we got a bunch of contexts, it turns to this picture.\n\nEvery memory context \n\nhas a firstchild pointer to the first element of its child contexts list,\n\nchains to neighbours with the help of the nextchild pointer and the prevchild pointer,  \n\nalso has a parent pointer to its parent context if it has, set to NULL if it has not.\n\n\nIn postgreSQL the most top memory context node is TopMemContext, which’s parent is NULL, in other words it’s the root of this upside down tree like relationship.\nWhenever a context is to be destroyed, the child contexts would be destroyed firstly  by list order. And if any child context also has child contexts, that child contexts would be destroyed ahead. This process invokes Recursively until  all child contexts under the root are destroyed, then the root context itself is destroyed. \n","categories":["PostgreSQL"],"tags":["DB"]}]