[{"title":"The general architecture of postgreSQL(1)","url":"/2021/04/04/The-general-architecture-of-postgreSQL-1/","content":"A general viewPostgreSQL is the most advanced Relation Database Management System around the world. It’s a huge system with many complex features. To understand the internal mechanism of PostgreSQL must be a chalange. Let’s start from something much easy to get a whole picture of the system.\nIn this post, I will explain:\n\nhow PostgreSQL works;\nthe process architecture;\nthe system layers;\n\nPostgrepSQL works as multi-processes: 1 master process, several helper processes and worker processes respective to every client.\n\nAll processes are single thread. If you know some services use async io such as nginx and redis, which are epoll driven on Linux implementation, that PostgreSQL use multi-process architecture must beyond your expectation. Actially, this makes sence, for PostgreSQL is heavy on both disk IO and computing, it might take a long time to finish just one query, async io do not allow one job takes such long time or other users be affected.\nWhen a client comes, the master process (named as “postgres”) just accept the connection and produce a new socket corresponding. Then the master process call Linux fork() to create a new worker process, which takes care on the new socket and serves this client ever since. And the worker process quits whenever some error occurs or the client close the connection.\nAll worker processes, helper processes like BGWriter, Vacuum, Logger, access to the Database files concurrently. In this context of PostgreSQL we call the databases as DB cluster, and we call the tables as relations.\n","categories":["PostgreSQL"],"tags":["DB"]},{"title":"The memory context of PostgreSQL","url":"/2021/04/15/The-memory-context-of-PostgreSQL/","content":"How to prevent memory leak is such an important topic for every C-language developer. After a long term run, the application eats every bit of RAM and runs so slowly that the OS needs a rebooting. Even worse sometime, the OS just throws a segment fault and shuts down the process immediately. Memory pool is a good fix for this, PostgreSQL has invited this feature after version 9 more or less. This reduced the raisk of memory leak.\nPostgreSQL implements memory infrastructure as The Momory Context. Here are some api you may familiar with:\n\n\n\nAPI\nFor What\n\n\n\nAllocSetContextCreateInternal/AllocSetContextCreate\ncreate  context\n\n\nMemoryContextDelete\nDestroy context\n\n\npalloc\nalloc memory from context\n\n\npfree\nfree memory back to context\n\n\nprealloc\nrealloc memory\n\n\nObviously, they would replace  libc alloc/free functions. I will explain how Memory Context works in this post.\nA tree like relationshipA memory context can specify:\n\na parent context\na child contexts list\n\nIf we got a bunch of contexts, it turns to this picture.\n\nEvery memory context \n\nhas a firstchild pointer to the first element of its child contexts list,\n\nchains to neighbours with the help of the nextchild pointer and the prevchild pointer,  \n\nalso has a parent pointer to its parent context if it has, set to NULL if it has not.\n\n\nIn postgreSQL the most top memory context node is TopMemContext, which’s parent is NULL, in other words it’s the root of this upside down tree like relationship.\nWhenever a context is to be destroyed, the child contexts would be destroyed firstly  by list order. And if any child context also has child contexts, that child contexts would be destroyed ahead. This process invokes Recursively until  all child contexts under the root are destroyed, then the root context itself is destroyed. \nHere is the definition  of MemoryContextData:\ntypedef struct MemoryContextData&#123;\tNodeTag\t\ttype;\t\t\t/* identifies exact kind of context */\t/* these two fields are placed here to minimize alignment wastage: */\tbool\t\tisReset;\t\t/* T = no space alloced since last reset */\tbool\t\tallowInCritSection; /* allow palloc in critical section */\tSize\t\tmem_allocated;\t/* track memory allocated for this context */\tconst MemoryContextMethods *methods;\t/* virtual function table */\tMemoryContext parent;\t\t/* NULL if no parent (toplevel context) */\tMemoryContext firstchild;\t/* head of linked list of children */\tMemoryContext prevchild;\t/* previous child of same parent */\tMemoryContext nextchild;\t/* next child of same parent */\tconst char *name;\t\t\t/* context name (just for debugging) */\tconst char *ident;\t\t\t/* context ID if any (just for debugging) */\tMemoryContextCallback *reset_cbs;\t/* list of reset/delete callbacks */&#125; MemoryContextData;\n\nThe most important members are:\n\nparent;\nfirstchild;\nprevchild and nextchild, obviously they are linked queue members;\n\nThe MemoryContextData make memory blocks connected to each other, while it has nothing to do with memory fragmentation.\nSolve the fragmentation problemIf the process malloc memory frequently, even they are freeed property, the system performance decreased after hour or days because of memory fragmentation problem. That malloc contiguous memory blocks and try to reuse memory is a good idea. PostgreSQL use AllocBlockData to manage memory blocks.\n\nThe block is divided into two parts:\n\nAllocBlockData saves information about this big block;\nNormal memory that will be used later.\n\ntypedef struct AllocBlockData&#123;\tAllocSet\taset;\t\t\t/* aset that owns this block */\tAllocBlock\tprev;\t\t\t/* prev block in aset&#x27;s blocks list, if any */\tAllocBlock\tnext;\t\t\t/* next block in aset&#x27;s blocks list, if any */\tchar\t   *freeptr;\t\t/* start of free space in this block */\tchar\t   *endptr;\t\t\t/* end of space in this block */&#125;\t\t\tAllocBlockData;\n\nBlocks are link together with the member prev and next. Of course 1 block is too little for most application, there must be bunch of blocks, these blocks are managed by the AllocSetContext structure. \n","categories":["PostgreSQL"],"tags":["DB"]},{"title":"Another introduce to sed","url":"/2021/04/08/another-introduce-to-sed/","content":"Why you should learn sedSed is a convenience text edit tool. It’s a free open source software, that means you can use it without paying a cent. If you\n\ndo text edit usually,\nwant to make changes to numerous files in minutes automatically rather than do it manually for hours,\nbe way from dull editing jobs.\n\nYou should learn sed. Unfortunately, sed is a “non-interactive” stream-orinted editor, which means:\n\nit does not work like notepad or vi, you will not see the text proccess.\nit’s stream orinted, sed always works on every single lines, not the whole file, that’s an limitation.\n\n"},{"title":"The general architecture of postgreSQL(2)","url":"/2021/04/06/The-general-architecture-of-postgreSQL-2/","content":"The nature of Database SystemAs PostgreSQL is a DBMS, let’s take a glance on the nature of DB. A text file with some lines of records comes to be a simple database file. Combined with an application manage that file it turns to be a database system. So simple, isn’t it ?\n\nBut the disk IO is very slow you must have notice that, we need some technology to speed it up, so we introduce caches. The cache layer works between the manage application and magnetic disk, any file blocks that hit the cache will just read from the cache rather than from disk, in other words read from memory directly.\n\nSo the nature of DMS is an application which manages some database files, always works with cache to speed up IO. \n","categories":["PostgreSQL"],"tags":["DB"]}]